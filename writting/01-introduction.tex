\section{Introduction}

\nocite{adams1995hitchhiker}

Ideas:
\begin{enumerate}
  \item \emph{krb-ccn} decouples authentication from access control because access rights
	are not associated with the possession of a key not to the ability of decrypting a
	the content's ciphertext (as in attribute-based encryption). Therefore, access control
	policies can be changed without the need to proactively re-distribute access keys.
  \item Users's privacy is preserved since the actual content producers are not aware of which
	is requesting a given content. This is possible because authentication and AC is handled
	by the KDC and not by the final content producer and because of the lack of source addresses
	on CCN interests.
  \item By leveraging the sinenergy between network names in CCN and Kerberos service-names-based AC, we are
	able to provide an effective AC policy by granting AC rights to namespaces (e.g., \emph{/uci/edu/filesystem/userA/*}).
	In IP Kerberos such AC policies are bounded to principals, with are basically names to services within an organization.
	Since in CCN all content is named by design, \emph{krb-ccn} eliminates the need for principals, leading to a cleaner and
	straightforward authentication and authorization system.
  \item \emph{krb-ccn} is also designed with efficiency in mind. As in IP Kerberos, the majority of cryptografic operations in the
	system consist on symmetric-key authenticated encryption. By avoiding computatially expensive operations (sucha as ABC, PKC, and Pairing Based Cryptography),
	\emph{krb-ccn} becomes suitable for scenarios where content producers are resource constrained devices, such as in an evetual CCN-IoT.
  \item The consumer application does not have to be aware of \emph{krb-ccn}. Based on the interest hierarchical name structure,
	the \emph{krb-ccn} local client is capable of fetching the apropriate TGS/TGT, or issue TGS and TGT requests as needed.
\end{enumerate}


Content-Centric Networking (CCN) is an emerging paradigm that emphasizes the transfer
of named data instead of hosts and interfaces. This shifts the security focus from
channels a la protocols such as TLS to the content itself. If content is sensitive
and must be protected, the architecture demands that it be properly encrypted so
that unauthorized consumers cannot view the data. Access control in CCN has been
well studied in recent years. The majority of solutions rely on long-lived public
and private key pairs to protect data. Specifically, data owners or producers
encrypt data under some access control policy with a public key corresponding to
an authorized consumer (or set of consumers). The recipient(s) use their
corresponding private key to decrypt the content.

In principle, this design achieves its goal of providing access control to content.
However, it suffers in two critical problems. The first is revocation. There is an
intrinsic time-of-check versus time-of-use problem with the standard CCN access
control strategy. Specifically, once content is encrypted under a recipient’s
public key, said recipient will always have access to the data barring destruction
of the private key. If a consumer’s access control rights change after content
is published, then said consumer can continue reading the data so long as it can
obtain an encrypted copy. Addressing this problem requires that access to content
always be preceded by an \emph{online} authorization check. Specifically, before
consumer $Cr_i$ accesses content $C(N)$ with name $N$, it must first acquire access
to $C(N)$. Such access will allow $Cr_i$ to read $C(N)$. Moreover, since access to
$C(N)$ at time $t$ might be allowed for $Cr_i$ but not $Cr_j \not= Cr_i$, $C(N)$ must
only be accessible by $Cr_i$. Generalizing this further means that each content is
uniquely encrypted, on demand, for each consumer at time $t$. Thus, encrypted content
must be bound to the state of an access control policy. Otherwise, caching this
content is, in theory, not possible.

The second critical problem is the inadvertent mixing of authentication and authorization.
In the standard approach, there is not online authentication or authorization. Possession
of a private key sufficiently satisfies both purposes. It is up to the producer to
statically enforce its authorization rules by only encrypting content for particular
consumers. This mixture of authentication and authorization is problematic for several
reasons. Firstly, it binds authorization rules to authentication identities. In
applications where authorization checks depend on more than a client identity, this is
not sufficient. Secondly, it requires that authentication be done solely by consumer-owned
private keys. In fact there are many circumstances where a client’s identity is ascertained
using information that is not a private key — passwords being the more prominent counter
example. In summation, it is advantageous to decouple authentication and authorization,
even in CCN. Kerberos is one system that allows us to partly address both of these open
problems. Specifically, Kerberos decouples authentication and authorization services
through the usage of tickets. It also allows services, e.g., content repositories, to
be accessed over an ephemeral session. Tickets permit the service to check the liveness
of authentication information and, therefore, limit the window of data use beyond revocation.

In this paper, we present Hydra, a system inspired by Kerberos for online access control
enforcement in CCN. Hydra separates consumer authentication and authorization into
separate services. It uses tickets or cookies to allow consumers to convey authorization
permissions to target servers, e.g., content repositories. Servers can use these cookies
to determine if requested content should be provided or not. Hydra also introduces a
novel naming scheme to bind consumer credentials to protected content objects. This
allows only authorized consumers to derive the names of protected content objects.
Producers use these derived names when checking authorization rights for target content
or namespaces. This naming scheme is orthogonal to Hydra and may be used in other
application settings to better make access control decisions.
