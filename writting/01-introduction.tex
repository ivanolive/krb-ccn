\section{Introduction}
Content-Centric Networking (CCN) is an emerging paradigm that emphasizes the transfer
of named data instead of hosts and interfaces. This shifts the security focus from
channels a la protocols such as TLS to the content itself. If content is sensitive
and must be protected, the architecture demands that it be properly encrypted so
that unauthorized consumers cannot view the data. Access control in CCN has been
well studied in recent years. The majority of solutions rely on long-lived public
and private key pairs to protect data. Specifically, data owners or producers
encrypt data under some access control policy with a public key corresponding to
an authorized consumer (or set of consumers). The recipient(s) use their
corresponding private key to decrypt the content.

In principle, this design achieves its goal of providing access control to content.
However, it suffers in two critical problems. The first is revocation. There is an
intrinsic time-of-check versus time-of-use problem with the standard CCN access
control strategy. Specifically, once content is encrypted under a recipient’s
public key, said recipient will always have access to the data barring destruction
of the private key. If a consumer’s access control rights change after content
is published, then said consumer can continue reading the data so long as it can
obtain an encrypted copy. Addressing this problem requires that access to content
always be preceded by an \emph{online} authorization check. Specifically, before
consumer $Cr_i$ accesses content $C(N)$ with name $N$, it must first acquire access
to $C(N)$. Such access will allow $Cr_i$ to read $C(N)$. Moreover, since access to
$C(N)$ at time $t$ might be allowed for $Cr_i$ but not $Cr_j \not= Cr_i$, $C(N)$ must
only be accessible by $Cr_i$. Generalizing this further means that each content is
uniquely encrypted, on demand, for each consumer at time $t$. Thus, encrypted content
must be bound to the state of an access control policy. Otherwise, caching this
content is, in theory, not possible.

The second critical problem is the inadvertent mixing of authentication and authorization.
In the standard approach, there is not online authentication or authorization. Possession
of a private key sufficiently satisfies both purposes. It is up to the producer to
statically enforce its authorization rules by only encrypting content for particular
consumers. This mixture of authentication and authorization is problematic for several
reasons. Firstly, it binds authorization rules to authentication identities. In
applications where authorization checks depend on more than a client identity, this is
not sufficient. Secondly, it requires that authentication be done solely by consumer-owned
private keys. In fact there are many circumstances where a client’s identity is ascertained
using information that is not a private key — passwords being the more prominent counter
example. In summation, it is advantageous to decouple authentication and authorization,
even in CCN. Kerberos is one system that allows us to partly address both of these open
problems. Specifically, Kerberos decouples authentication and authorization services
through the usage of tickets. It also allows services, e.g., content repositories, to
be accessed over an ephemeral session. Tickets permit the service to check the liveness
of authentication information and, therefore, limit the window of data use beyond revocation.

In this paper, we present Hydra, a system inspired by Kerberos for online access control
enforcement in CCN. Hydra separates consumer authentication and authorization into
separate services. It uses tickets or cookies to allow consumers to convey authorization
permissions to target servers, e.g., content repositories. Servers can use these cookies
to determine if requested content should be provided or not. Hydra also introduces a
novel naming scheme to bind consumer credentials to protected content objects. This
allows only authorized consumers to derive the names of protected content objects.
Producers use these derived names when checking authorization rights for target content
or namespaces. This naming scheme is orthogonal to Hydra and may be used in other
application settings to better make access control decisions.
